
<h1 class="sectionedit1" id="jitcompiler">JITCompiler</h1>
<div class="level1">

<p>
Благодаря Jit компилятору, компилятор может очень быстро запустить методы без повторной их компиляции. То есть при первом разе он их скомпилировал и весь машинный код лежит в куче. Потом дополнительной компиляции не требуется. После завершения работы программы, куча очищается.
</p>
<hr />

<p>
<strong>System.Runtime.ProfileOptimization</strong> - causes the CLR to record file what methods get JIT compiled while app is running. Потом JIT будет просто в другом потоке компилировать эти методы
</p>

</div>
<!-- EDIT1 SECTION "JITCompiler" [1-777] -->
<h3 class="sectionedit2" id="оптимизация_машинного_кода">Оптимизация машинного кода</h3>
<div class="level3">

<p>
Также Jit компилятор позволяет позволяет оптимизировать машинный код, при выполнении такой код гораздо производительней.
2 параметра влияют на оптимизацию:
/optimize и /debug
Над оптимизированным кодом хуже управлять отладкой, зато оптимизируется поток управления программой. Код становится меньше по размерам 
</p>

</div>
<!-- EDIT2 SECTION "Оптимизация машинного кода" [778-1397] -->
<h3 class="sectionedit3" id="pdb_файл">PDB файл</h3>
<div class="level3">

<p>
Также компилятор порождает Program Database file (PDB), если использован параметр /debug(+/full/pdbonly)
</p>

<p>
-Pdb file helps the debugger find local variables and map the IL instructions to source code
</p>

</div>
<!-- EDIT3 SECTION "PDB файл" [1398-1667] -->
<h3 class="sectionedit4" id="минусы_двойного_компилирования">Минусы двойного компилирования</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> It hurts performance</div>
</li>
<li class="level1"><div class="li"> Allocates dynamic memory</div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Минусы двойного компилирования" [1668-] -->