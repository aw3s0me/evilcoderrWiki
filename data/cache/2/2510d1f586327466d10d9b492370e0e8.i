a:45:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:11:"JITCompiler";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:507:"Благодаря Jit компилятору, компилятор может очень быстро запустить методы без повторной их компиляции. То есть при первом разе он их скомпилировал и весь машинный код лежит в куче. Потом дополнительной компиляции не требуется. После завершения работы программы, куча очищается.";}i:2;i:27;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:534;}i:6;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:534;}i:7;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:534;}i:8;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:540;}i:9;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:"System.Runtime.ProfileOptimization";}i:2;i:542;}i:10;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:576;}i:11;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:199:" - causes the CLR to record file what methods get JIT compiled while app is running. Потом JIT будет просто в другом потоке компилировать эти методы";}i:2;i:578;}i:12;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:778;}i:13;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:778;}i:14;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:50:"Оптимизация машинного кода";i:1;i:3;i:2;i:778;}i:2;i:778;}i:15;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:778;}i:16;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:778;}i:17;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:558:"Также Jit компилятор позволяет позволяет оптимизировать машинный код, при выполнении такой код гораздо производительней.
2 параметра влияют на оптимизацию:
/optimize и /debug
Над оптимизированным кодом хуже управлять отладкой, зато оптимизируется поток управления программой. Код становится меньше по размерам ";}i:2;i:839;}i:18;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1398;}i:19;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1398;}i:20;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"PDB файл";i:1;i:3;i:2;i:1398;}i:2;i:1398;}i:21;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1398;}i:22;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1398;}i:23;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:151:"Также компилятор порождает Program Database file (PDB), если использован параметр /debug(+/full/pdbonly)";}i:2;i:1421;}i:24;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1572;}i:25;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1572;}i:26;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:92:"-Pdb file helps the debugger find local variables and map the IL instructions to source code";}i:2;i:1574;}i:27;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1666;}i:28;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1668;}i:29;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:58:"Минусы двойного компилирования";i:1;i:3;i:2;i:1668;}i:2;i:1668;}i:30;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1668;}i:31;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:1736;}i:32;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1736;}i:33;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1736;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" It hurts performance";}i:2;i:1740;}i:35;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1761;}i:36;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1761;}i:37;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1761;}i:38;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1761;}i:39;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:" Allocates dynamic memory";}i:2;i:1765;}i:40;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1790;}i:41;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1790;}i:42;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:1790;}i:43;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1790;}i:44;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:1790;}}