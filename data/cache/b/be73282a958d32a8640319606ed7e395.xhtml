
<h1 class="sectionedit1" id="процессы">Процессы</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Процессы" [1-31] -->
<h2 class="sectionedit2" id="контекст">Контекст</h2>
<div class="level2">

<p>
Контекст процесса состоит из <strong>пользовательского контекста</strong> и <strong>контекста ядра</strong>
</p>

<p>
<a href="/dokuwiki/lib/exe/detail.php?id=%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B&amp;media=wiki:1.gif" class="media" title="wiki:1.gif"><img src="/dokuwiki/lib/exe/fetch.php?w=450&amp;tok=94ef41&amp;media=wiki:1.gif" class="media" alt="" width="450" /></a>
</p>

</div>
<!-- EDIT2 SECTION "Контекст" [32-230] -->
<h3 class="sectionedit3" id="пользовательский_контекст">Пользовательский контекст</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> инициализируемые неизменяемые данные (например, константы);</div>
</li>
<li class="level1"><div class="li"> инициализируемые изменяемые данные (все переменные, начальные значения которых присваиваются на этапе компиляции);</div>
</li>
<li class="level1"><div class="li"> неинициализируемые изменяемые данные (все статические переменные, которым не присвоены начальные значения на этапе компиляции);</div>
</li>
<li class="level1"><div class="li"> стек пользователя;</div>
</li>
<li class="level1"><div class="li"> данные, расположенные в динамически выделяемой памяти (например, с помощью стандартных библиотечных C функций malloc(), calloc(), realloc()).</div>
</li>
</ul>
<ol>
<li class="level1"><div class="li"> Исполняемый код и инициализируемые данные составляют содержимое файла программы, который исполняется в контексте процесса.   </div>
</li>
<li class="level1"><div class="li"> Пользовательский стек применяется при работе процесса в пользовательском режиме (user-mode).</div>
</li>
</ol>

</div>
<!-- EDIT3 SECTION "Пользовательский контекст" [231-1549] -->
<h3 class="sectionedit4" id="контекст_ядра">Контекст ядра</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> системный контекст </div>
</li>
<li class="level1"><div class="li"> регистровый контекст</div>
</li>
</ul>

</div>
<!-- EDIT4 SECTION "Контекст ядра" [1550-1670] -->
<h2 class="sectionedit5" id="идентификация_процесса">Идентификация процесса</h2>
<div class="level2">

<p>
Каждый процесс в операционной системе получает уникальный идентификационный номер – <strong>PID (process identificator).</strong>
</p>

<p>
При создании нового процесса операционная <strong>система пытается присвоить ему свободный номер больший</strong>, чем у процесса, <em>созданного перед ним.</em>
</p>

<p>
Если таких свободных номеров не оказывается (например, мы достигли максимально возможного номера для процесса), то операционная система выбирает минимальный номер из всех свободных номеров.
</p>
<ul>
<li class="level1"><div class="li"> В операционной системе Linux присвоение идентификационных номеров процессов начинается с номера 0, который получает процесс kernel при старте операционной системы.</div>
</li>
</ul>

</div>
<!-- EDIT5 SECTION "Идентификация процесса" [1671-2832] -->
<h2 class="sectionedit6" id="состояние_процесса">Состояние процесса</h2>
<div class="level2">

<p>
<a href="/dokuwiki/lib/exe/detail.php?id=%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B&amp;media=wiki:2.gif" class="media" title="wiki:2.gif"><img src="/dokuwiki/lib/exe/fetch.php?w=450&amp;tok=19ce01&amp;media=wiki:2.gif" class="media" alt="" width="450" /></a>
</p>
<ul>
<li class="level1"><div class="li"> В состоянии исполнение в режиме пользователя процесс выполняет прикладные инструкции пользователя. </div>
</li>
<li class="level1"><div class="li"> В состоянии исполнение в режиме ядра выполняются инструкции ядра операционной системы в контексте текущего процесса (например, при обработке системного вызова или прерывания). </div>
</li>
<li class="level1"><div class="li"> Из состояния исполнение в режиме пользователя процесс не может непосредственно перейти в состояния ожидание, готовность и закончил исполнение. </div>
</li>
<li class="level1"><div class="li"> Такие переходы возможны только через промежуточное состояние «исполняется в режиме ядра» . </div>
</li>
<li class="level1"><div class="li"> Также запрещен прямой переход из состояния готовность в состояние исполнение в режиме пользователя.</div>
</li>
</ul>

</div>
<!-- EDIT6 SECTION "Состояние процесса" [2833-4058] -->
<h2 class="sectionedit7" id="иерархия">Иерархия</h2>
<div class="level2">

<p>
При создании ребенка (<strong>PPID – parent process identificator) изменяет свое значение на значение 1,</strong> соответствующее идентификатору процесса init, время жизни которого определяет время функционирования операционной системы.
</p>

</div>
<!-- EDIT7 SECTION "Иерархия" [4059-4466] -->
<h3 class="sectionedit8" id="порождение_процесса">Порождение процесса</h3>
<div class="level3">

<p>
Единственный способ - с помощью fork
</p>
<pre class="code">  pid_t fork(void);</pre>

<p>
Все данные родителя копируются в ребенке, и код ребенка начинает работу со строчки где сработал fork
</p>

</div>
<!-- EDIT8 SECTION "Порождение процесса" [4467-4780] -->
<h3 class="sectionedit9" id="получение_pid_ppid">Получение pid, ppid</h3>
<div class="level3">

<p>
С помощью функций 
</p>
<pre class="code">  pid = getpid();
  ppid = getppid();</pre>

<p>
Проверка где родитель где ребенок
</p>
<pre class="code">  pid = fork();
  if(pid == -1){
      ...
      /* ошибка */
      ...
  } else if (pid == 0){
      ...
      /* ребенок */
      ...
  } else {
      ...
      /* родитель */
      ...
  }</pre>

</div>
<!-- EDIT9 SECTION "Получение pid, ppid" [4781-5199] -->
<h3 class="sectionedit10" id="выход_из_процесса">Выход из процесса</h3>
<div class="level3">

<p>
При выполнении этой функции происходит <strong>сброс всех частично заполненных буферов</strong> ввода-вывода с закрытием соответствующих потоков (файлов, pipe, FIFO, сокетов), после чего инициируется системный вызов прекращения работы процесса и перевода его в состояние закончил исполнение.
</p>
<pre class="code">  void exit(int status);</pre>

</div>
<!-- EDIT10 SECTION "Выход из процесса" [5200-5773] -->
<h2 class="sectionedit11" id="exec">Exec</h2>
<div class="level2">

<p>
Системный вызов exec() должен создать двоичный образ запускаемого файла, загрузить и запустить его. Слово «загрузить» не обязательно означает «запись в память двоичный образ», так как Linux поддерживает загрузку по требуемым частям.
</p>

</div>
<!-- EDIT11 SECTION "Exec" [5774-] -->