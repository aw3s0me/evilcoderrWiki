====== Исключения ======
Исключение - ситуация, когда член не в состоянии решить возложенную на него задачу
  - Основывается на SEH - структурная обраб-а исключений
  - Если в try нет исключения, то нету перехода в catch, а сразу в finally
  - КОД в finally ВЫПОЛНЯЕТСЯ ВСЕГДА
  - Все исключения производные от System.Exception
  - Просмотр блоков catch сверху вниз -> более специализированные исключения нужно ставить выше, сначала самые младшие и в самом низу - System.Exception, иначе ошибка, так как в младшие будут недостижимыми
  - Если есть в потоке необработанное исключение, то после его нахождения, CLR уничтожает этот поток. + в журнал записывается запись об исключении (приложение Event Viewer)
  - При обнаружении catch CLR Исполняет внутренние блоки finally, при этом не один блок finally не выполняется до завершения дейсвтия с catch
       try {
           //здесь код, требующий обработки или очистки ресурсов
       }
       catch (InvalidOperationException) {
           //код к-ый восстанавливается после ошибки типа InvalidOperationException
       }
       catch (IOException) {
           //код к-ый восстанавливается после ошибки типа IOException
       }
       catch {
           //код к-ый восстанавливается после остальных исключений
           
           //после перехвата их обычно вбрасывают повторно
           throw;
       }
       finally {
           //код выполняющий очистку ресурсов
           посел операций начатых в try
       }
==== Способ восстановления после исключения ====
  * Еще раз вбросить (throw;)
  * Вбросить исключение другого типа, передавая расположенному выше в стеке коду больше сведений об исключении
  * Позволить потоку покинуть блок catch
==== CLS-совместимые исключения ====
Для них используем catch без параметров. Если не попадет в catch -> RunTimeWrappedException
==== Контракты ====
Позволяют проверить аргументы перед модификацией состояния. Проверка не проходит -> исключение.
==== ПРАВИЛА ====
  - Если юзаем lock, то в finally отключаем запирание
  - Если юзаем using, то в finally вызываем Dispose
  - Если юзаем foreach, то в finally для объекта IEnumerator вызываем Dispose
  - Если определяем деструктор, то в finally вызываем метод Finalize базового класса
  - НЕ НАДО ПЕРЕХВАТЫВАТЬ ВСЕ ИСКЛЮЧЕНИЯ
       
       