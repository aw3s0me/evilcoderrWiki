====== Группы процессов ======
Родственные процессы можно преобразовать в группу процессов (дерево)
===== Смысл их создавать =====
Смысл объединения чтобы мы могли совершать над процессами одинаковые действия
===== Особенности =====
  * группа процессов существует когда существует в ней хотя бы 1 процесс
  * При рождении процесса он попадает в ту группу в к-ой создан родительский процесс
  * Можно перемещать из одной группы в другую
  * Группы объединяются в сеансы
===== Терминал =====
Каждый сеанс связан со своим управляющим терминалом, с которым общается пользователь с процессами сеанса
  * ОДНОМУ ТЕРМИНАЛУ ОДИН СЕАНС!
  * МОГУТ СУЩЕСТВОВАТЬ СЕАНСЫ НЕ ИМЕЮЩИЕ УПРАВЛЯЮЩЕГО ТЕРМИНАЛА
===== Номер группы =====
Каждая группа процессов в системе получает собственный уникальный номер. Узнать этот номер можно с помощью системного вызова getpgid()
    pid_t getpgid(pid_t pid);
Атрибут - процесс из этой группы, узнать номер может процесс для самого себя или для процесса из своего сеанса, ИНАЧЕ -1
----
Для текущего процесса
    pid_t getpgrp(void);
===== Перевод в другую группу =====
  * В новую группу не может перейти процесс, являющийся лидером группы
Для перевода процесса в другую группу процессов, возможно, с одновременным ее созданием, применяется системный вызов setpgid()
    int setpgid(pid_t pid, pid_t pgid);
Параметр pid является идентификатором процесса, который нужно перевести в другую группу, а параметр pgid – идентификатором группы процессов, в которую предстоит перевести этот процесс. 
  * Если параметр pid равен 0, то считается, что процесс переводит в другую группу самого себя.
  * Если параметр pgid равен 0, то в Linux считается, что процесс переводится в группу с идентификатором, совпадающим с идентификатором процесса, определяемого первым параметром.
  * Если значения, определяемые параметрами pid и pgid, равны, то создается новая группа с идентификатором, совпадающим с идентификатором переводимого процесса, состоящая первоначально только из этого процесса. Переход в другую группу без создания новой группы возможен только в пределах одного сеанса  
----
Процесс может перевести в другую группу:
  * либо самого себя (и то не во всякую и не всегда), 
  * либо свой процесс-ребенок, который не выполнял системный вызов exec(), т.е. не запускал на выполнение другую программу.
При определенных значениях параметров системного вызова создается **новая группа процессов** с идентификатором, совпадающим с идентификатором переводимого процесса, состоящая первоначально только из одного этого процесса
===== Номер сеанса =====
Системный вызов возвращает идентификатор сеанса для процесса с идентификатором pid. Если параметр pid равен 0, то возвращается идентификатор сеанса для данного процесса
     pid_t getsid(pid_t pid);
===== Переход в другой сеанс =====
Можно применять к неЛИДЕРУ! Приводит к созданию новой группы где процесс становится лидером
----
Если сеанс имеет управляющий терминал, то этот терминал обязательно приписывается к некоторой группе процессов, входящей в сеанс. Такая группа процессов называется текущей группой процессов для данного сеанса. Все процессы, входящие в текущую группу процессов, могут совершать операции ввода-вывода, используя управляющий терминал. Все остальные группы процессов сеанса называются фоновыми группами, а процессы, входящие в них – фоновыми процессами
  * При завершении работы процесса – лидера сеанса все процессы из текущей группы сеанса получают сигнал SIGHUP
  * SIGINT при нажатии клавиш <ctrl> и <c>
  * SIGQUIT при нажатии клавиш <ctrl> и <4>.