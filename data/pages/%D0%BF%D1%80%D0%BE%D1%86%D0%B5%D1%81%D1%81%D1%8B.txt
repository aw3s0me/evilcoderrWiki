====== Процессы ======
===== Контекст =====
Контекст процесса состоит из **пользовательского контекста** и **контекста ядра**

{{:wiki:1.gif?450|}}

==== Пользовательский контекст ====
  * инициализируемые неизменяемые данные (например, константы);
  * инициализируемые изменяемые данные (все переменные, начальные значения которых присваиваются на этапе компиляции);
  * неинициализируемые изменяемые данные (все статические переменные, которым не присвоены начальные значения на этапе компиляции);
  * стек пользователя;
  * данные, расположенные в динамически выделяемой памяти (например, с помощью стандартных библиотечных C функций malloc(), calloc(), realloc()).

  - Исполняемый код и инициализируемые данные составляют содержимое файла программы, который исполняется в контексте процесса.   
  - Пользовательский стек применяется при работе процесса в пользовательском режиме (user-mode).
==== Контекст ядра ====
  * системный контекст 
  * регистровый контекст
===== Идентификация процесса =====
Каждый процесс в операционной системе получает уникальный идентификационный номер – **PID (process identificator).** 

При создании нового процесса операционная **система пытается присвоить ему свободный номер больший**, чем у процесса, //созданного перед ним.// 

Если таких свободных номеров не оказывается (например, мы достигли максимально возможного номера для процесса), то операционная система выбирает минимальный номер из всех свободных номеров.

  * В операционной системе Linux присвоение идентификационных номеров процессов начинается с номера 0, который получает процесс kernel при старте операционной системы.

===== Состояние процесса =====
{{:wiki:2.gif?450|}}
  * В состоянии исполнение в режиме пользователя процесс выполняет прикладные инструкции пользователя. 
  * В состоянии исполнение в режиме ядра выполняются инструкции ядра операционной системы в контексте текущего процесса (например, при обработке системного вызова или прерывания). 
  * Из состояния исполнение в режиме пользователя процесс не может непосредственно перейти в состояния ожидание, готовность и закончил исполнение. 
  * Такие переходы возможны только через промежуточное состояние «исполняется в режиме ядра» . 
  * Также запрещен прямой переход из состояния готовность в состояние исполнение в режиме пользователя.
===== Иерархия =====
При создании ребенка (**PPID – parent process identificator) изменяет свое значение на значение 1,** соответствующее идентификатору процесса init, время жизни которого определяет время функционирования операционной системы.
==== Порождение процесса ====
Единственный способ - с помощью fork
    pid_t fork(void);
Все данные родителя копируются в ребенке, и код ребенка начинает работу со строчки где сработал fork
==== Получение pid, ppid ====
С помощью функций 
    pid = getpid();
    ppid = getppid();
Проверка где родитель где ребенок
    pid = fork();
    if(pid == -1){
        ...
        /* ошибка */
        ...
    } else if (pid == 0){
        ...
        /* ребенок */
        ...
    } else {
        ...
        /* родитель */
        ...
    }
==== Выход из процесса ====
При выполнении этой функции происходит **сброс всех частично заполненных буферов** ввода-вывода с закрытием соответствующих потоков (файлов, pipe, FIFO, сокетов), после чего инициируется системный вызов прекращения работы процесса и перевода его в состояние закончил исполнение.
    void exit(int status);
===== Exec =====
Системный вызов exec() должен создать двоичный образ запускаемого файла, загрузить и запустить его. Слово "загрузить" не обязательно означает "запись в память двоичный образ", так как Linux поддерживает загрузку по требуемым частям.