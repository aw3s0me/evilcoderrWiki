a:2:{s:7:"current";a:8:{s:4:"date";a:2:{s:7:"created";i:1377441334;s:8:"modified";i:1377441683;}s:7:"creator";s:10:"Aleksander";s:4:"user";s:10:"evilcoderr";s:11:"last_change";a:7:{s:4:"date";i:1377441683;s:2:"ip";s:13:"46.161.167.72";s:4:"type";s:1:"E";s:2:"id";s:16:"grayscale_filter";s:4:"user";s:10:"evilcoderr";s:3:"sum";s:0:"";s:5:"extra";s:0:"";}s:8:"internal";a:2:{s:5:"cache";b:1;s:3:"toc";b:1;}s:11:"description";a:1:{s:8:"abstract";s:503:"global
void rgba_to_greyscale(const uchar4* const rgbaImage,
                     unsigned char* const greyImage,
                     int numRows, int numCols)
{
  
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  uchar4 rgba = rgbaImage[idx];
  greyImage[idx] = .299f * rgba.x + .587f * rgba.y + .114f * rgba.z;
  
//TODO
//Fill in the kernel to convert from color to greyscale
//the mapping from components of a uchar4 to RGBA is:
// .x -> R ; .y -> G ; .z -> B ; .w -> A
//
//The output (greyâ€¦";}s:8:"relation";a:1:{s:10:"firstimage";s:0:"";}s:11:"contributor";a:1:{s:10:"evilcoderr";s:10:"Aleksander";}}s:10:"persistent";a:5:{s:4:"date";a:2:{s:7:"created";i:1377441334;s:8:"modified";i:1377441683;}s:7:"creator";s:10:"Aleksander";s:4:"user";s:10:"evilcoderr";s:11:"last_change";a:7:{s:4:"date";i:1377441683;s:2:"ip";s:13:"46.161.167.72";s:4:"type";s:1:"E";s:2:"id";s:16:"grayscale_filter";s:4:"user";s:10:"evilcoderr";s:3:"sum";s:0:"";s:5:"extra";s:0:"";}s:11:"contributor";a:1:{s:10:"evilcoderr";s:10:"Aleksander";}}}